<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lecteur Audio Ultime</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chargement de la bibliothèque three.js pour la visualisation 3D -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000;
            color: #E0E0E0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            /* Correction : suppression de 'overflow: hidden' pour permettre le défilement */
            background: linear-gradient(135deg, #1f1f1f 0%, #0a0a0a 100%);
        }

        .container {
            position: relative;
            background: rgba(26, 26, 26, 0.7);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 2.5rem;
            border-radius: 2rem;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            max-width: 900px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 2rem;
            text-align: center;
        }

        @media (min-width: 768px) {
            .container {
                flex-direction: row;
                text-align: left;
            }
        }

        h1 {
            color: #fff;
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            letter-spacing: -1px;
        }
        
        p.subtitle {
            color: #B0B0B0;
            margin-bottom: 2rem;
            font-size: 0.95rem;
        }

        .left-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .right-panel {
            flex: 1.5;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .input-group, .controls, .modes {
            padding: 1.5rem;
            background: rgba(30, 30, 30, 0.7);
            border-radius: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: transform 0.3s ease;
        }
        
        .input-group:hover, .controls:hover, .modes:hover {
            transform: translateY(-5px);
        }

        .file-label {
            display: inline-block;
            background: linear-gradient(45deg, #4CAF50, #2E8B57);
            color: white;
            padding: 0.75rem 2rem;
            border-radius: 9999px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            font-weight: 600;
        }
        
        .file-label:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 20px rgba(76, 175, 80, 0.2);
        }

        #file-input {
            display: none;
        }

        #song-display {
            font-size: 1rem;
            font-weight: 600;
            color: #fff;
            min-height: 1.5rem;
            margin-top: 0.5rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .controls-grid {
            display: grid;
            gap: 1.5rem;
        }
        
        @media (min-width: 768px) {
            .controls-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .control-group {
            text-align: left;
        }

        .control-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #B0B0B0;
            font-size: 0.9rem;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 10px;
            background: #333;
            border-radius: 9999px;
            outline: none;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
            transition: background-color 0.2s ease;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #2E8B57;
        }

        .slider-value {
            font-size: 0.8rem;
            width: 3rem;
            color: #999;
            font-weight: 600;
            text-align: right;
        }

        .main-buttons {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            margin-top: 1rem;
        }

        .main-button {
            background: #4A4A4A;
            color: #E0E0E0;
            padding: 0.8rem 1.8rem;
            border-radius: 9999px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.2s ease;
        }
        
        .main-button:hover {
            background: #666;
            transform: translateY(-2px);
        }

        .mode-button {
            padding: 0.6rem 1.2rem;
            border-radius: 9999px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.2s ease;
            background: #2C2C2C;
            color: #999;
        }
        
        .mode-button:hover {
            background: #444;
            transform: translateY(-2px);
        }

        .mode-button.active {
            background: #4CAF50;
            color: white;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.2);
        }
        
        .visualizer-container {
            width: 100%;
            height: 350px;
            border-radius: 1.5rem;
            overflow: hidden;
            background: #0a0a0a;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        #visualizer-canvas {
            width: 100%;
            height: 100%;
        }

    </style>
</head>
<body>

<div class="container">
    <div class="left-panel">
        <div class="header">
            <h1 class="text-4xl">Lecteur de Musique Magique</h1>
            <p class="subtitle">Importez une musique locale et appliquez des effets en temps réel !</p>
        </div>

        <!-- Zone de téléversement de fichier -->
        <div class="input-group">
            <label for="file-input" class="file-label">Importer une Musique</label>
            <input type="file" id="file-input" accept="audio/*">
            <div id="song-display">Aucune musique chargée</div>
            <div class="main-buttons">
                <button id="play-pause-button" class="main-button">Lecture</button>
                <button id="stop-button" class="main-button">Arrêt</button>
            </div>
        </div>

        <!-- Panneau de contrôle des effets -->
        <div class="controls">
            <h2 class="text-xl font-semibold mb-4 text-white">Contrôles Audio</h2>
            <div class="controls-grid">
                <!-- Vitesse -->
                <div class="control-group">
                    <label for="speed-slider">Vitesse <span id="speed-value">1.00x</span></label>
                    <div class="slider-container">
                        <input type="range" id="speed-slider" min="0.5" max="2.0" value="1.0" step="0.01">
                    </div>
                </div>
                <!-- Volume -->
                <div class="control-group">
                    <label for="volume-slider">Volume <span id="volume-value">100%</span></label>
                    <div class="slider-container">
                        <input type="range" id="volume-slider" min="0" max="1" value="1" step="0.01">
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="right-panel">
        <!-- Visualiseur Audio -->
        <div class="visualizer-container">
            <canvas id="visualizer-canvas"></canvas>
        </div>

        <!-- Modes sonores -->
        <div class="modes">
            <h2 class="text-xl font-semibold mb-4 text-white">Modes Sonores</h2>
            <div class="flex flex-wrap justify-center gap-2">
                <button id="mode-normal" class="mode-button active">Normal</button>
                <button id="mode-slowed-reverb" class="mode-button">Slowed + Reverb</button>
                <button id="mode-bass-boost" class="mode-button">Bass Boost</button>
                <button id="mode-vocal-boost" class="mode-button">Vocal Boost</button>
            </div>
        </div>

        <!-- Égaliseur -->
        <div class="controls">
            <h2 class="text-xl font-semibold mb-4 text-white">Égaliseur Manuel</h2>
            <div class="controls-grid">
                <div class="control-group">
                    <label for="low-eq-slider">Basses (-12dB) <span id="low-eq-value">0</span></label>
                    <div class="slider-container">
                        <input type="range" id="low-eq-slider" min="-24" max="24" value="0">
                    </div>
                </div>
                <div class="control-group">
                    <label for="mid-eq-slider">Médiums (-12dB) <span id="mid-eq-value">0</span></label>
                    <div class="slider-container">
                        <input type="range" id="mid-eq-slider" min="-24" max="24" value="0">
                    </div>
                </div>
                <div class="control-group">
                    <label for="high-eq-slider">Aigus (-12dB) <span id="high-eq-value">0</span></label>
                    <div class="slider-container">
                        <input type="range" id="high-eq-slider" min="-24" max="24" value="0">
                    </div>
                </div>
                <div class="control-group">
                    <label for="panning-slider">Panoramique <span id="panning-value">Centre</span></label>
                    <div class="slider-container">
                        <input type="range" id="panning-slider" min="-1" max="1" value="0" step="0.1">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    // Éléments DOM
    const fileInput = document.getElementById('file-input');
    const songDisplay = document.getElementById('song-display');
    const playPauseButton = document.getElementById('play-pause-button');
    const stopButton = document.getElementById('stop-button');
    const speedSlider = document.getElementById('speed-slider');
    const speedValueDisplay = document.getElementById('speed-value');
    const volumeSlider = document.getElementById('volume-slider');
    const volumeValueDisplay = document.getElementById('volume-value');
    const lowEqSlider = document.getElementById('low-eq-slider');
    const lowEqValueDisplay = document.getElementById('low-eq-value');
    const midEqSlider = document.getElementById('mid-eq-slider');
    const midEqValueDisplay = document = document.getElementById('mid-eq-value');
    const highEqSlider = document.getElementById('high-eq-slider');
    const highEqValueDisplay = document.getElementById('high-eq-value');
    const panningSlider = document.getElementById('panning-slider');
    const panningValueDisplay = document.getElementById('panning-value');
    const modeButtons = document.querySelectorAll('.mode-button');

    // API Web Audio
    // L'AudioContext doit être créé ou résumé après une interaction de l'utilisateur.
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    let sourceNode;
    let analyserNode;
    let gainNode;
    let convolverNode;
    let pannerNode;
    let eqFilters = [];
    let audioBuffer;
    let isPlaying = false;
    let currentMode = 'normal';
    let lastPlaybackTime = 0;
    let lastPosition = 0;

    // SCÈNE 3D
    let scene, camera, renderer, particles, particleCount, geometry, material;

    // Gère la configuration initiale du graphe audio
    function setupAudioGraph() {
        // Crée les nœuds audio si ce n'est pas déjà fait
        analyserNode = audioContext.createAnalyser();
        analyserNode.fftSize = 256;

        gainNode = audioContext.createGain();
        pannerNode = audioContext.createPanner();
        pannerNode.panningModel = 'equalpower';

        // Crée les filtres de l'égaliseur
        const frequencies = [125, 1000, 8000]; // Basses, Médiums, Aigus
        eqFilters = frequencies.map(freq => {
            const filter = audioContext.createBiquadFilter();
            filter.type = 'peaking';
            filter.frequency.setValueAtTime(freq, audioContext.currentTime);
            filter.Q.setValueAtTime(1, audioContext.currentTime);
            filter.gain.setValueAtTime(0, audioContext.currentTime);
            return filter;
        });

        // Crée le nœud de réverbération
        convolverNode = audioContext.createConvolver();
        convolverNode.buffer = createReverbImpulseResponse();

        // Connexion par défaut : source -> filtres EQ -> réverbération (désactivée) -> panner -> gain -> analyseur -> destination
        if (sourceNode) {
            let lastNode = sourceNode;
            eqFilters.forEach(filter => {
                lastNode.connect(filter);
                lastNode = filter;
            });

            // Connexion de la réverbération (initialement désactivée)
            lastNode.connect(pannerNode);
            pannerNode.connect(analyserNode);
            analyserNode.connect(gainNode);
            gainNode.connect(audioContext.destination);
        }
    }
    
    // Met à jour la connexion du graphe audio en fonction des modes
    function updateAudioGraphConnections() {
        // Déconnecte tous les nœuds pour éviter les boucles
        if (sourceNode) {
            sourceNode.disconnect();
            eqFilters.forEach(filter => filter.disconnect());
            convolverNode.disconnect();
            pannerNode.disconnect();
            analyserNode.disconnect();
            gainNode.disconnect();

            // Reconnecte le graphe
            let lastNode = sourceNode;
            
            // Connecte les filtres de l'égaliseur
            eqFilters.forEach(filter => {
                lastNode.connect(filter);
                lastNode = filter;
            });

            // Connecte la réverbération si le mode est actif
            if (currentMode === 'slowed-reverb') {
                lastNode.connect(convolverNode);
                convolverNode.connect(pannerNode);
            } else {
                lastNode.connect(pannerNode);
            }

            pannerNode.connect(analyserNode);
            analyserNode.connect(gainNode);
            gainNode.connect(audioContext.destination);
        }
    }

    // Fonction pour générer une réponse impulsionnelle pour la réverbération
    function createReverbImpulseResponse() {
        const length = audioContext.sampleRate * 2;
        const impulse = audioContext.createBuffer(2, length, audioContext.sampleRate);
        const impulseL = impulse.getChannelData(0);
        const impulseR = impulse.getChannelData(1);

        for (let i = 0; i < length; i++) {
            impulseL[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
            impulseR[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
        }
        return impulse;
    }

    // Crée et connecte la source audio
    function createSource(buffer) {
        if (sourceNode) {
            sourceNode.stop();
            sourceNode.disconnect();
        }
        sourceNode = audioContext.createBufferSource();
        sourceNode.buffer = buffer;
        sourceNode.loop = true; // Permet de boucler la musique
        
        // Initialise le graphe audio
        setupAudioGraph();
        updateAudioGraphConnections();
        
        // Démarre la lecture
        sourceNode.start(0, lastPosition);
        isPlaying = true;
        playPauseButton.textContent = "Pause";
        lastPlaybackTime = audioContext.currentTime;
    }

    // Gestion du chargement du fichier
    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                const arrayBuffer = event.target.result;
                audioContext.decodeAudioData(arrayBuffer)
                    .then(buffer => {
                        audioBuffer = buffer;
                        songDisplay.textContent = `Lecture : ${file.name}`;
                        lastPosition = 0; // Réinitialise la position
                        createSource(audioBuffer);
                        setMode(currentMode);
                    })
                    .catch(error => console.error('Erreur lors du décodage du fichier audio', error));
            };
            reader.readAsArrayBuffer(file);
        }
    });

    // Contrôles de lecture
    playPauseButton.addEventListener('click', () => {
        if (!audioBuffer) {
            songDisplay.textContent = "Veuillez charger une musique d'abord !";
            return;
        }

        // Il faut un geste de l'utilisateur pour démarrer le contexte audio
        if (audioContext.state === 'suspended') {
            audioContext.resume();
        }

        if (isPlaying) {
            audioContext.suspend();
            isPlaying = false;
            playPauseButton.textContent = "Lecture";
            lastPosition += audioContext.currentTime - lastPlaybackTime;
        } else {
            // Si la source a été arrêtée (par le bouton stop), on la recrée
            if (sourceNode && sourceNode.buffer) {
                audioContext.resume();
                isPlaying = true;
                playPauseButton.textContent = "Pause";
                lastPlaybackTime = audioContext.currentTime;
            } else {
                createSource(audioBuffer);
            }
        }
    });

    stopButton.addEventListener('click', () => {
        if (audioBuffer) {
            if (sourceNode) {
                sourceNode.stop();
            }
            isPlaying = false;
            playPauseButton.textContent = "Lecture";
            lastPosition = 0;
            songDisplay.textContent = `Arrêté : ${audioBuffer.name}`;
        }
    });

    // Événements pour les sliders
    speedSlider.addEventListener('input', (e) => {
        const rate = parseFloat(e.target.value);
        if (sourceNode) {
            sourceNode.playbackRate.setValueAtTime(rate, audioContext.currentTime);
        }
        speedValueDisplay.textContent = `${rate.toFixed(2)}x`;
    });

    volumeSlider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        if (gainNode) {
            gainNode.gain.setValueAtTime(value, audioContext.currentTime);
        }
        volumeValueDisplay.textContent = `${Math.round(value * 100)}%`;
    });

    lowEqSlider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        if (eqFilters[0]) {
            eqFilters[0].gain.setValueAtTime(value, audioContext.currentTime);
        }
        lowEqValueDisplay.textContent = `${value}dB`;
    });

    midEqSlider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        if (eqFilters[1]) {
            eqFilters[1].gain.setValueAtTime(value, audioContext.currentTime);
        }
        midEqValueDisplay.textContent = `${value}dB`;
    });

    highEqSlider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        if (eqFilters[2]) {
            eqFilters[2].gain.setValueAtTime(value, audioContext.currentTime);
        }
        highEqValueDisplay.textContent = `${value}dB`;
    });
    
    panningSlider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        if (pannerNode) {
            pannerNode.setPosition(value, 0, 0);
        }
        panningValueDisplay.textContent = value === 0 ? "Centre" : value > 0 ? "Droite" : "Gauche";
    });

    // Gestion des modes sonores
    function setMode(mode) {
        currentMode = mode;
        modeButtons.forEach(btn => btn.classList.remove('active'));
        document.getElementById(`mode-${mode}`).classList.add('active');

        // Réinitialise tous les curseurs
        speedSlider.value = 1.0;
        speedValueDisplay.textContent = "1.00x";
        lowEqSlider.value = 0;
        lowEqValueDisplay.textContent = "0dB";
        midEqSlider.value = 0;
        midEqValueDisplay.textContent = "0dB";
        highEqSlider.value = 0;
        highEqValueDisplay.textContent = "0dB";
        panningSlider.value = 0;
        panningValueDisplay.textContent = "Centre";

        // Applique les paramètres du mode
        if (sourceNode) {
            sourceNode.playbackRate.setValueAtTime(1.0, audioContext.currentTime);
            pannerNode.setPosition(0, 0, 0);
            eqFilters[0].gain.setValueAtTime(0, audioContext.currentTime);
            eqFilters[1].gain.setValueAtTime(0, audioContext.currentTime);
            eqFilters[2].gain.setValueAtTime(0, audioContext.currentTime);
        }
        
        switch (mode) {
            case 'normal':
                break;
            case 'slowed-reverb':
                if (sourceNode) {
                    sourceNode.playbackRate.setValueAtTime(0.75, audioContext.currentTime);
                    speedValueDisplay.textContent = '0.75x';
                }
                break;
            case 'bass-boost':
                if (eqFilters[0]) eqFilters[0].gain.setValueAtTime(12, audioContext.currentTime);
                lowEqSlider.value = 12;
                lowEqValueDisplay.textContent = "12dB";
                break;
            case 'vocal-boost':
                if (eqFilters[1]) eqFilters[1].gain.setValueAtTime(8, audioContext.currentTime);
                midEqSlider.value = 8;
                midEqValueDisplay.textContent = "8dB";
                break;
        }

        updateAudioGraphConnections();
    }

    modeButtons.forEach(button => {
        button.addEventListener('click', (e) => {
            const mode = e.target.id.split('-')[1];
            setMode(mode);
        });
    });

    // --- VISUALISEUR 3D AVEC THREE.JS ---

    // Initialisation de la scène 3D
    function init3DVisualizer() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, canvas.offsetWidth / canvas.offsetHeight, 0.1, 1000);
        camera.position.z = 5;

        renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true });
        renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
        renderer.setClearColor(0x000000, 0); // Fond transparent

        // Crée des particules
        particleCount = 5000;
        geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];

        for (let i = 0; i < particleCount; i++) {
            // Positions aléatoires
            positions.push(
                (Math.random() - 0.5) * 20,
                (Math.random() - 0.5) * 20,
                (Math.random() - 0.5) * 20
            );
            // Couleurs aléatoires
            colors.push(Math.random(), Math.random(), Math.random());
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

        material = new THREE.PointsMaterial({
            size: 0.1,
            vertexColors: true,
            transparent: true,
            opacity: 0.8
        });

        particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = canvas.offsetWidth / canvas.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
        });
    }

    // Boucle d'animation
    function animate() {
        requestAnimationFrame(animate);

        if (isPlaying && analyserNode) {
            const bufferLength = analyserNode.fftSize;
            const dataArray = new Uint8Array(bufferLength);
            analyserNode.getByteFrequencyData(dataArray);

            const averageFrequency = dataArray.reduce((sum, value) => sum + value, 0) / bufferLength;
            const scale = 1 + (averageFrequency / 255) * 2; // Échelle de 1 à 3
            
            // Fait réagir le visualiseur 3D à l'audio
            particles.scale.set(scale, scale, scale);
            particles.rotation.x += 0.001;
            particles.rotation.y += 0.002;
        }

        renderer.render(scene, camera);
    }
    
    // Démarre l'animation sur le chargement de la fenêtre
    window.onload = function () {
        init3DVisualizer();
        animate();
    }

</script>

</body>
</html>
